using System;using UnityEngine;using System.Collections;//Kyle Codeusing Photon.Pun;using Photon.Pun.Demo.Asteroids;using Photon.Pun.UtilityScripts;using UnityEngine.SceneManagement;using TMPro;//end kyle code[RequireComponent (typeof (Controller2D))]public class Player : MonoBehaviourPunCallbacks{	//Daniel code	public AudioSource damageSound;	public AudioSource steps;	//end Daniel code	//Kyle code	public PhotonView photonView;	private TextMeshPro nameText;	public bool forceMovement = false;	private KidsGameManager gm;	public bool hasFinishedLevel = false;	//end Kyle code	public float maxJumpHeight = 4;	public float minJumpHeight = 1;	public float timeToJumpApex = .4f;	float accelerationTimeAirborne = .2f;	float accelerationTimeGrounded = .1f;	public float moveSpeed = 6;	public float ropeVelocity;	public Vector2 wallJumpClimb;	public Vector2 wallJumpOff;	public Vector2 wallLeap;	public float wallSlideSpeedMax = 3;	public float wallStickTime = .25f;	float timeToWallUnstick;	float gravity;	float maxJumpVelocity;	float minJumpVelocity;	Vector3 velocity;	float velocityXSmoothing;	Controller2D controller;    private Animator ani;    Vector3 characterScale;    float characterScaleX;   float characterScaley;   public bool onRope;   public bool attachedToRope;   public bool canMove;   public Vector3 activeCheckpoint;   //Begin Kyle Code   void Awake()   {	   photonView = GetComponent<PhotonView>();	   nameText = transform.GetComponentInChildren<TextMeshPro>();	   nameText.text = photonView.Owner.NickName;	   gm = GameObject.Find("KidsGameManager").GetComponent<KidsGameManager>();	   DontDestroyOnLoad(this);   }	//End Kyle Code   void Start() {	   	   ExitGames.Client.Photon.Hashtable initialProps = new ExitGames.Client.Photon.Hashtable() {{"finished", false}};	   PhotonNetwork.LocalPlayer.SetCustomProperties(initialProps);	   	   //Kyle line of code	   activeCheckpoint = transform.position;	   Debug.Log("set checkpoint to " + activeCheckpoint);	   controller = GetComponent<Controller2D> ();		gravity = -(2 * maxJumpHeight) / Mathf.Pow (timeToJumpApex, 2);		maxJumpVelocity = Mathf.Abs(gravity) * timeToJumpApex;		minJumpVelocity = Mathf.Sqrt (2 * Mathf.Abs (gravity) * minJumpHeight);		print ("Gravity: " + gravity + "  Jump Velocity: " + maxJumpVelocity);        ani = GetComponent<Animator>();        characterScale = transform.localScale;        characterScaleX = characterScale.x;        characterScaley = characterScale.y;        onRope = false;        canMove = true;	}	void Update()	{		//Begin Kyle Code		//stops physics if player is not local instance, can be overriden		if (!photonView.IsMine && !forceMovement)		{			return;		}		if (hasFinishedLevel)		{			return;		}		//End Kyle Code 		checkFalling();		Vector2 input = new Vector2 (Input.GetAxisRaw ("Horizontal"), Input.GetAxisRaw ("Vertical"));		int wallDirX = (controller.collisions.left) ? -1 : 1;        if(Input.GetKeyDown(KeyCode.A) || Input.GetKeyDown(KeyCode.D)){            if(input.x > 0 && canMove)            {                characterScale.x = characterScaleX;                Vector3 t = nameText.transform.localScale;                nameText.transform.localScale = new Vector3(1.603427f,t.y,t.z);                ani.SetTrigger("run");            }            if(input.x < 0 && canMove)            {                Vector3 t = nameText.transform.localScale;                nameText.transform.localScale = new Vector3(-1.603427f,t.y,t.z);                characterScale.x = -characterScaleX;                ani.SetTrigger("run");            }        }            transform.localScale = characterScale;        		float targetVelocityX = input.x * moveSpeed;		if (canMove)		{			velocity.x = Mathf.SmoothDamp(velocity.x, targetVelocityX, ref velocityXSmoothing,				(controller.collisions.below) ? accelerationTimeGrounded : accelerationTimeAirborne);		}		bool wallSliding = false;		if ((controller.collisions.left || controller.collisions.right) && (!controller.collisions.below) &&		    (Input.GetKey(KeyCode.Q)))		{			velocity.y = 0;		}		if ((controller.collisions.left || controller.collisions.right) && (!controller.collisions.below && velocity.y < 0) && (wallDirX == input.x)) {			wallSliding = true;			if (velocity.y < -wallSlideSpeedMax) {				velocity.y = -wallSlideSpeedMax;			}			if (timeToWallUnstick > 0) {				velocityXSmoothing = 0;				velocity.x = 0;				if (input.x != wallDirX && input.x != 0) {					timeToWallUnstick -= Time.deltaTime;				}				else {					timeToWallUnstick = wallStickTime;				}			}			else {				timeToWallUnstick = wallStickTime;			}		}		if (Input.GetKeyDown (KeyCode.Space)) {            ani.SetTrigger("jump");            if (controller.collisions.left || controller.collisions.right) {				if (wallDirX == input.x) {					velocity.x = -wallDirX * wallJumpClimb.x;					velocity.y = wallJumpClimb.y;				}				else if (input.x == 0) {					velocity.x = -wallDirX * wallLeap.x;					velocity.y = wallLeap.y;					StartCoroutine(movementLockout2(.3f, false));				}				else {					velocity.x = -wallDirX * wallLeap.x;					velocity.y = wallLeap.y;					StartCoroutine(movementLockout2(.3f, false));				}			}			if (controller.collisions.below) {				velocity.y = maxJumpVelocity;			}        }		if (Input.GetKeyUp (KeyCode.Space)) {			if (velocity.y > minJumpVelocity) {				velocity.y = minJumpVelocity;			}		}				if (onRope && Input.GetKeyUp(KeyCode.W))		{			velocity.y = 0;            ani.SetTrigger("climb_idle");        }		        if (onRope && Input.GetKeyUp(KeyCode.S))        {            velocity.y = 0;            ani.SetTrigger("climb_idle");        }		if (onRope && Input.GetKeyDown(KeyCode.W))		{			velocity.y = ropeVelocity;            ani.SetTrigger("climb");		}		if (onRope && Input.GetKeyDown(KeyCode.S))		{			velocity.y = -ropeVelocity;            ani.SetTrigger("climb");		}				if (!onRope)		{			velocity.y += gravity * Time.deltaTime;		}				controller.Move(velocity * Time.deltaTime, input);				if (controller.collisions.above || controller.collisions.below) {			velocity.y = 0;		}        if(!Input.anyKey && !onRope && canMove)            ani.SetTrigger("idle");	}	private void OnCollisionEnter2D(Collision2D other)	{		if (!photonView.IsMine && !forceMovement)		{			return;		}		if (other.gameObject.layer == 12)		{			damage();		}	}	private void OnTriggerEnter2D(Collider2D other)	{		if (!photonView.IsMine && !forceMovement)		{			return;		}		//this is a shit way to do checkpoints but we don't really have the time at this point		if (other.gameObject.layer == 13)		{			if (activeCheckpoint.y < other.ClosestPoint(transform.position).y)			{				activeCheckpoint = other.ClosestPoint(transform.position);			}		}		if (other.gameObject.layer == 14)		{			Debug.Log("finish flaggggg");			ExitGames.Client.Photon.Hashtable initialProps = new ExitGames.Client.Photon.Hashtable() {{"finished", true}};			PhotonNetwork.LocalPlayer.SetCustomProperties(initialProps);			//Debug.Log(CheckFinished())			if (!hasFinishedLevel && CheckFinished())			{				LoadNextLevel();			}		}		if (other.gameObject.layer == 10)		{			onRope = true;		}	}	private void OnTriggerExit2D(Collider2D other)	{		if (other.gameObject.layer == 10)		{			onRope = false;		}	}	//Kyle Function	public bool CheckFinished()	{		Debug.Log("checkfinished called");		if (hasFinishedLevel)		{			return false;		}		/*if (!PhotonNetwork.IsMasterClient && !forceMovement)		{			return false;		}*/		hasFinishedLevel = false;		canMove = false;		velocity.x = 0;		//only stop the game if there are less than 2 unfinished players		//should be 2 if variables worked correctly		int finishedPlayers = 0;		int unfinishedPlayers = 2;		foreach (Photon.Realtime.Player p in PhotonNetwork.PlayerList)		{			if (p.IsLocal)			{				Debug.Log("we don't care about you >:(");				continue;			}			Debug.Log("check props " + p.NickName);			if (p.CustomProperties.TryGetValue("finished", out object isPlayerFinished))			{				if (!(bool) isPlayerFinished)				{					Debug.Log("Player "+ p.NickName +" has not finished");					unfinishedPlayers -= 1;				}				else				{					Debug.Log("Player "+ p.NickName +" has finished");					finishedPlayers += 1;				}			}			else			{				Debug.Log("could not find finished property");				unfinishedPlayers -= 1;			}		}		if (gm.isScorable)		{			if (finishedPlayers == 0)			{				Debug.Log("You Placed First!");				PhotonNetwork.LocalPlayer.AddScore(5);			}			if (finishedPlayers == 1)			{				Debug.Log("You Placed Second!");				PhotonNetwork.LocalPlayer.AddScore(3);			}			if (finishedPlayers == 2)			{				Debug.Log("You Placed Third!");				PhotonNetwork.LocalPlayer.AddScore(1);			}		}		if (unfinishedPlayers <= 0)		{			return false;		}		//players have finished the level!! Yay!		return true;	}	//end Kyle Function	public void damage()	{		//play damage animation		StartCoroutine(movementLockout(1f, true));        //transform.position = activeCheckpoint;		GameObject _damageObject = GameObject.Find("DamageAudio");		if (_damageObject)		{			AudioSource _damageSound = _damageObject.GetComponent<AudioSource>();			if (_damageSound != null)			{				damageSound = _damageSound;				damageSound.Play();			}		}	}	private void checkFalling()	{		if (transform.position.y < -10)		{            StartCoroutine(movementLockout(1f, true));			//transform.position = activeCheckpoint;		}	}	IEnumerator movementLockout(float lockoutTime, bool killMomentum)    {        ani.SetTrigger("fall");		canMove = false;		if (killMomentum)		{			velocity.x = 0;		}		yield return new WaitForSeconds(lockoutTime);        ani.SetTrigger("idle");        if (!hasFinishedLevel)        {	        canMove = true;	        transform.position = activeCheckpoint;        }    }    IEnumerator movementLockout2(float lockoutTime, bool killMomentum)    {        canMove = false;        if (killMomentum)        {        velocity.x = 0;        }        yield return new WaitForSeconds(lockoutTime);        if (!hasFinishedLevel)			canMove = true;    }    public void setCheckpoint()	{		activeCheckpoint = transform.position;	}	private void OnEnable()	{		SceneManager.sceneLoaded += OnSceneLoaded;	}	void OnSceneLoaded(Scene scene, LoadSceneMode mode)	{		Debug.Log("OnSceneLoaded: " + scene.name);		activeCheckpoint = new Vector3(0,0);	}	void OnDisable()	{		SceneManager.sceneLoaded -= OnSceneLoaded;	}		//pun callback whenever synced variables are updated	public override void OnPlayerPropertiesUpdate(Photon.Realtime.Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)	{		if (!PhotonNetwork.IsMasterClient)		{			return;		}		Debug.Log("Props were changed!");		if (changedProps.TryGetValue("finished", out object isPlayerReady))		{			Debug.Log("Found the prop \"finished\"");			if ((bool)isPlayerReady)			{				CheckFinished();			}		}		else		{			Debug.Log("Did not find the prop \"finished\"");		}	}	[PunRPC]	public void MoveToStartPosition()	{		Debug.Log("movetostartposition");		Vector3 position = new Vector3((PhotonNetwork.LocalPlayer.GetPlayerNumber()-PhotonNetwork.CurrentRoom.PlayerCount/2)*2,0,0);		transform.position = position;		activeCheckpoint = Vector3.zero;		hasFinishedLevel = false;		canMove = true;	}		public void LoadNextLevel()	{		if (PhotonNetwork.IsMasterClient)		{			LoadLevelFromGM();			MoveToStartPosition();		}		else		{			photonView.RPC("LoadLevelFromGM",RpcTarget.MasterClient);			MoveToStartPosition();		}	}	[PunRPC]	public void LoadLevelFromGM()	{		gm.LoadNextLevel();	}}